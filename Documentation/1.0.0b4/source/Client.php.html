<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * RouterOS API client implementation.

 * 
 * RouterOS is the flag product of the company MikroTik and is a powerful router software. One of its many abilities is to allow control over it via an API. This package provides a client for that API, in turn allowing you to use PHP to control RouterOS hosts.
 * 
 * PHP version 5
 * 
 * @category  Net
 * @package   PEAR2_Net_RouterOS
 * @author    Vasil Rangelov &lt;boen.robot@gmail.com&gt;
 * @copyright 2011 Vasil Rangelov
 * @license   http://www.gnu.org/copyleft/lesser.html LGPL License 2.1
 * @version   1.0.0b4
 * @link      http://pear2.php.net/PEAR2_Net_RouterOS
 */
/**
 * The namespace declaration.
 */
namespace PEAR2\Net\RouterOS;

/**
 * Refers to transmitter direction constants.
 */
use PEAR2\Net\Transmitter\Stream as S;

/**
 * Refers to the cryptography constants.
 */
use PEAR2\Net\Transmitter\NetworkStream AS N;

/**
 * A RouterOS client.
 * 
 * Provides functionality for easily communicating with a RouterOS host.
 * 
 * @category Net
 * @package  PEAR2_Net_RouterOS
 * @author   Vasil Rangelov &lt;boen.robot@gmail.com&gt;
 * @license  http://www.gnu.org/copyleft/lesser.html LGPL License 2.1
 * @link     http://pear2.php.net/PEAR2_Net_RouterOS
 */
class Client
{
    /**
     * Used in {@link isRequestActive()} to limit search only to requests
     * that have a callback.
     */
    const FILTER_CALLBACK = 1;
    /**
     * Used in {@link isRequestActive()} to limit search only to requests
     * that use the buffer.
     */
    const FILTER_BUFFER = 2;
    /**
     * Used in {@link isRequestActive()} to indicate no limit in search.
     */
    const FILTER_ALL = 3;

    /**
     * @var Communicator The communicator for this client.
     */
    protected $com;

    /**
     * @var int The number of currently pending requests.
     */
    protected $pendingRequestsCount = 0;

    /**
     * @var array An array of responses that have not yet been extracted or
     *     passed to a callback. Key is the tag of the request, and the value
     *     is an array of associated responses.
     */
    protected $responseBuffer = array();

    /**
     * @var array An array of callbacks to be executed as responses come.
     *     Key is the tag of the request, and the value is the callback for it.
     */
    protected $callbacks = array();
    
    /**
     * @var Registry A registry for the operations. Particularly helpful at
     *     persistent connections.
     */
    protected $registry = null;

    /**
     * @var bool Whether to stream future responses.
     */
    private $_streamingResponses = false;

    /**
     * Creates a new instance of a RouterOS API client.
     * 
     * Creates a new instance of a RouterOS API client with the specified
     * settings.
     * 
     * @param string   $host     Hostname (IP or domain) of the RouterOS server.
     * @param string   $username The RouterOS username.
     * @param string   $password The RouterOS password.
     * @param int|null $port     The port on which the RouterOS server provides
     *     the API service. You can also specify NULL, in which case the port
     *     will automatically be chosen between 8728 and 8729, depending on the
     *     value of $crypto.
     * @param bool     $persist  Whether or not the connection should be a
     *     persistent one.
     * @param float    $timeout  The timeout for the connection.
     * @param string   $crypto   The encryption for this connection. Must be one
     *     of the PEAR2\Net\Transmitter\NetworkStream::CRYPTO_* constants. Off
     *     by default. RouterOS currently supports only TLS, but the setting is
     *     provided in this fashion for forward compatibility's sake. And for
     *     the sake of simplicity, if you specify an encryption, don't specify a
     *     context and your default context uses the value &quot;DEFAULT&quot; for
     *     ciphers, &quot;ADH&quot; will be automatically added to the list of ciphers.
     * @param resource $context  A context for the socket.
     * 
     * @see sendSync()
     * @see sendAsync()
     */
    public function __construct(
        $host,
        $username,
        $password = '',
        $port = 8728,
        $persist = false,
        $timeout = null,
        $crypto = N::CRYPTO_OFF,
        $context = null
    ) {
        $this-&gt;com = new Communicator(
            $host,
            $port,
            $persist,
            $timeout,
            $username . '/' . $password,
            $crypto,
            $context
        );
        $timeout = null == $timeout
            ? ini_get('default_socket_timeout')
            : (int) $timeout;
        //Login the user if necessary
        if ((!$persist
            || !($old = $this-&gt;com-&gt;getTransmitter()-&gt;lock(S::DIRECTION_ALL)))
            &amp;&amp; $this-&gt;com-&gt;getTransmitter()-&gt;isFresh()
        ) {
            if (!static::login($this-&gt;com, $username, $password, $timeout)) {
                $this-&gt;com-&gt;close();
                throw new DataFlowException(
                    'Invalid username or password supplied.',
                    DataFlowException::CODE_INVALID_CREDENTIALS
                );
            }
        }
        
        if (isset($old)) {
            $this-&gt;com-&gt;getTransmitter()-&gt;lock($old, true);
        }
        
        if ($persist) {
            $this-&gt;registry = new Registry(&quot;{$host}:{$port}/{$username}&quot;);
        }
    }
    
    /**
     * A shorthand gateway.
     * 
     * This is a magic PHP method that allows you to call the object as a
     * function. Depending on the argument given, one of the other functions in
     * the class is invoked and its returned value is returned by this function.
     * 
     * @param mixed $arg Value can be either a {@link Request} to send, which
     *     would be sent asynchoniously if it has a tag, and synchroniously if
     *     not, a number to loop with or NULL to complete all pending requests.
     *     Any other value is converted to string and treated as the tag of a
     *     request to complete.
     * 
     * @return mixed Whatever the long form function would have returned.
     */
    public function __invoke($arg = null)
    {
        if (is_int($arg) || is_double($arg)) {
            return $this-&gt;loop($arg);
        } elseif ($arg instanceof Request) {
            return '' == $arg-&gt;getTag() ? $this-&gt;sendSync($arg)
                : $this-&gt;sendAsync($arg);
        } elseif (null === $arg) {
            return $this-&gt;completeRequest();
        }
        return $this-&gt;completeRequest((string) $arg);
    }

    /**
     * Login to a RouterOS connection.
     * 
     * @param Communicator $com      The communicator to attempt to login to.
     * @param string       $username The RouterOS username.
     * @param string       $password The RouterOS password.
     * @param int|null     $timeout  The time to wait for each response. NULL
     *     waits indefinetly.
     * 
     * @return bool TRUE on success, FALSE on failure.
     */
    public static function login(
        Communicator $com,
        $username, 
        $password = '',
        $timeout = null
    ) {
        if (null !== ($remoteCharset = $com-&gt;getCharset($com::CHARSET_REMOTE))
            &amp;&amp; null !== ($localCharset = $com-&gt;getCharset($com::CHARSET_LOCAL))
        ) {
            $password = iconv(
                $localCharset,
                $remoteCharset . '//IGNORE//TRANSLIT',
                $password
            );
        }
        $old = null;
        try {
            if ($com-&gt;getTransmitter()-&gt;isPersistent()) {
                $old = $com-&gt;getTransmitter()-&gt;lock(S::DIRECTION_ALL);
                $result = self::_login($com, $username, $password, $timeout);
                $com-&gt;getTransmitter()-&gt;lock($old, true);
                return $result;
            }
            return self::_login($com, $username, $password, $timeout);
        } catch (\Exception $e) {
            if ($com-&gt;getTransmitter()-&gt;isPersistent() &amp;&amp; null !== $old) {
                $com-&gt;getTransmitter()-&gt;lock($old, true);
            }
            throw ($e instanceof NotSupportedException
            || $e instanceof UnexpectedValueException
            || !$com-&gt;getTransmitter()-&gt;isDataAwaiting()) ? new SocketException(
                'This is not a compatible RouterOS service',
                SocketException::CODE_SERVICE_INCOMPATIBLE,
                $e
            ) : $e;
        }
    }

    /**
     * Login to a RouterOS connection.
     * 
     * This is the actual login procedure, applied regardless of persistence and
     * charset settings.
     * 
     * @param Communicator $com      The communicator to attempt to login to.
     * @param string       $username The RouterOS username.
     * @param string       $password The RouterOS password. Potentially parsed
     *     already by iconv.
     * @param int|null     $timeout  The time to wait for each response. NULL
     *     waits indefinetly.
     * 
     * @return bool TRUE on success, FALSE on failure.
     */
    private static function _login(
        Communicator $com,
        $username,
        $password = '',
        $timeout = null
    ) {
        $request = new Request('/login');
        $request-&gt;send($com);
        $response = new Response($com, false, $timeout);
        $request-&gt;setArgument('name', $username);
        $request-&gt;setArgument(
            'response',
            '00' . md5(
                chr(0) . $password
                . pack('H*', $response-&gt;getArgument('ret'))
            )
        );
        $request-&gt;send($com);
        $response = new Response($com, false, $timeout);
        return $response-&gt;getType() === Response::TYPE_FINAL
            &amp;&amp; null === $response-&gt;getArgument('ret');
    }
    
    /**
     * Sets the charset(s) for this connection.
     * 
     * Sets the charset(s) for this connection. The specified charset(s) will be
     * used for all future requests and responses. When sending,
     * {@link Communicator::CHARSET_LOCAL} is converted to
     * {@link Communicator::CHARSET_REMOTE}, and when receiving,
     * {@link Communicator::CHARSET_REMOTE} is converted to
     * {@link Communicator::CHARSET_LOCAL}. Setting NULL to either charset will
     * disable charset convertion, and data will be both sent and received &quot;as
     * is&quot;.
     * 
     * @param mixed $charset     The charset to set. If $charsetType is
     *     {@link Communicator::CHARSET_ALL}, you can supply either a string to
     *     use for all charsets, or an array with the charset types as keys, and
     *     the charsets as values.
     * @param int   $charsetType Which charset to set. Valid values are the
     *     Communicator::CHARSET_* constants. Any other value is treated as
     *     {@link Communicator::CHARSET_ALL}.
     * 
     * @return string|array The old charset. If $charsetType is
     *     {@link Communicator::CHARSET_ALL}, the old values will be returned as
     *     an array with the types as keys, and charsets as values.
     * @see Communicator::setDefaultCharset()
     */
    public function setCharset(
        $charset,
        $charsetType = Communicator::CHARSET_ALL
    ) {
        return $this-&gt;com-&gt;setCharset($charset, $charsetType);
    }
    
    /**
     * Gets the charset(s) for this connection.
     * 
     * @param int $charsetType Which charset to get. Valid values are the
     *     Communicator::CHARSET_* constants. Any other value is treated as
     *     {@link Communicator::CHARSET_ALL}.
     * 
     * @return string|array The current charset. If $charsetType is
     *     {@link Communicator::CHARSET_ALL}, the current values will be
     *     returned as an array with the types as keys, and charsets as values.
     * @see setCharset()
     */
    public function getCharset($charsetType)
    {
        return $this-&gt;com-&gt;getCharset($charsetType);
    }

    /**
     * Sends a request and waits for responses.
     * 
     * @param Request  $request  The request to send.
     * @param callback $callback Optional. A function that is to be executed
     *     when new responses for this request are available. The callback takes
     *     two parameters. The {@link Response} object as the first, and the
     *     {@link Client} object as the second one. If the function returns
     *     TRUE, the request is canceled. Note that the callback may be executed
     *     one last time after that with a response that notifies about the
     *     canceling.
     * 
     * @return self|Client The client object.
     * @see completeRequest()
     * @see loop()
     * @see cancelRequest()
     */
    public function sendAsync(Request $request, $callback = null)
    {
        //Error checking
        $tag = $request-&gt;getTag();
        if ('' == $tag) {
            throw new DataFlowException(
                'Asynchonous commands must have a tag.',
                DataFlowException::CODE_TAG_REQUIRED
            );
        }
        if ($this-&gt;isRequestActive($tag)) {
            throw new DataFlowException(
                'There must not be multiple active requests sharing a tag.',
                DataFlowException::CODE_TAG_UNIQUE
            );
        }
        if (null !== $callback &amp;&amp; !is_callable($callback, true)) {
            throw new UnexpectedValueException(
                'Invalid callback provided.',
                UnexpectedValueException::CODE_CALLBACK_INVALID
            );
        }
        
        $this-&gt;send($request);

        if (null === $callback) {
            //Register the request at the buffer
            $this-&gt;responseBuffer[$tag] = array();
        } else {
            //Prepare the callback
            $this-&gt;callbacks[$tag] = $callback;
        }
        return $this;
    }

    /**
     * Checks if a request is active.
     * 
     * Checks if a request is active. A request is considered active if it's a
     * pending request and/or has responses that are not yet extracted.
     * 
     * @param string $tag    The tag of the request to look for.
     * @param int    $filter One of the FILTER_* consntants. Limits the search
     *     to the specified places.
     * 
     * @return bool TRUE if the request is active, FALSE otherwise.
     * @see getPendingRequestsCount()
     * @see completeRequest()
     */
    public function isRequestActive($tag, $filter = self::FILTER_ALL)
    {
        $result = 0;
        if ($filter &amp; self::FILTER_CALLBACK) {
            $result |= (int) array_key_exists($tag, $this-&gt;callbacks);
        }
        if ($filter &amp; self::FILTER_BUFFER) {
            $result |= (int) array_key_exists($tag, $this-&gt;responseBuffer);
        }
        return 0 !== $result;
    }

    /**
     * Sends a request and gets the full response.
     * 
     * @param Request $request The request to send.
     * 
     * @return ResponseCollection The received responses as a collection.
     * @see sendAsync()
     * @see close()
     */
    public function sendSync(Request $request)
    {
        $tag = $request-&gt;getTag();
        if ('' == $tag) {
            $this-&gt;send($request);
        } else {
            $this-&gt;sendAsync($request);
        }
        return $this-&gt;completeRequest($tag);
    }

    /**
     * Completes a specified request.
     * 
     * Starts an event loop for the RouterOS callbacks and finishes when a
     * specified request is completed.
     * 
     * @param string $tag The tag of the request to complete. Setting NULL
     *     completes all requests.
     * 
     * @return ResponseCollection A collection of {@link Response} objects that
     *     haven't been passed to a callback function or previously extracted
     *     with {@link extractNewResponses()}. Returns an empty collection when
     *     $tag is set to NULL (responses can still be extracted).
     */
    public function completeRequest($tag = null)
    {
        $hasNoTag = '' == $tag;
        $result = $hasNoTag ? array()
            : $this-&gt;extractNewResponses($tag)-&gt;toArray();
        while ((!$hasNoTag &amp;&amp; $this-&gt;isRequestActive($tag))
        || ($hasNoTag &amp;&amp; 0 !== $this-&gt;getPendingRequestsCount())
        ) {
            $newReply = $this-&gt;dispatchNextResponse(null);
            if ($newReply-&gt;getTag() === $tag) {
                if ($hasNoTag) {
                    $result[] = $newReply;
                }
                if ($newReply-&gt;getType() === Response::TYPE_FINAL) {
                    if (!$hasNoTag) {
                        $result = array_merge(
                            $result,
                            $this-&gt;isRequestActive($tag)
                            ? $this-&gt;extractNewResponses($tag)-&gt;toArray()
                            : array()
                        );
                    }
                    break;
                }
            }
        }
        return new ResponseCollection($result);
    }

    /**
     * Extracts responses for a request.
     * 
     * Gets all new responses for a request that haven't been passed to a
     * callback and clears the buffer from them.
     * 
     * @param string $tag The tag of the request to extract new responses for.
     *     Specifying NULL with extract new responses for all requests.
     * 
     * @return ResponseCollection A collection of {@link Response} objects for
     *     the specified request.
     * @see loop()
     */
    public function extractNewResponses($tag = null)
    {
        if (null === $tag) {
            $result = array();
            foreach (array_keys($this-&gt;responseBuffer) as $tag) {
                $result = array_merge(
                    $result,
                    $this-&gt;extractNewResponses($tag)-&gt;toArray()
                );
            }
            return new ResponseCollection($result);
        } elseif ($this-&gt;isRequestActive($tag, self::FILTER_CALLBACK)) {
            return new ResponseCollection(array());
        } elseif ($this-&gt;isRequestActive($tag, self::FILTER_BUFFER)) {
            $result = $this-&gt;responseBuffer[$tag];
            if (!empty($result)) {
                if (end($result)-&gt;getType() === Response::TYPE_FINAL) {
                    unset($this-&gt;responseBuffer[$tag]);
                } else {
                    $this-&gt;responseBuffer[$tag] = array();
                }
            }
            return new ResponseCollection($result);
        } else {
            throw new DataFlowException(
                'No such request, or the request has already finished.',
                DataFlowException::CODE_UNKNOWN_REQUEST
            );
        }
    }

    /**
     * Starts an event loop for the RouterOS callbacks.
     * 
     * Starts an event loop for the RouterOS callbacks and finishes when there
     * are no more pending requests or when a specified timeout has passed
     * (whichever comes first).
     * 
     * @param int $timeout_s  Timeout for the loop. If NULL, there is no time
     *     limit.
     * @param int $timeout_us Microseconds to add to the time limit.
     * 
     * @return bool TRUE when there are any more pending requests, FALSE
     *     otherwise.
     * @see extractNewResponses()
     * @see getPendingRequestsCount()
     */
    public function loop($timeout_s = null, $timeout_us = 0)
    {
        try {
            if (null === $timeout_s) {
                while ($this-&gt;getPendingRequestsCount() !== 0) {
                    $this-&gt;dispatchNextResponse(null);
                }
            } else {
                list($start_us, $start_s) = explode(' ', microtime());
                while ($this-&gt;getPendingRequestsCount() !== 0
                    &amp;&amp; ($timeout_s &gt;= 0 || $timeout_us &gt;= 0)
                ) {
                    $this-&gt;dispatchNextResponse($timeout_s, $timeout_us);
                    list($end_us, $end_s) = explode(' ', microtime());

                    $timeout_s -= $end_s - $start_s;
                    $timeout_us -= $end_us - $start_us;
                    if ($timeout_us &lt;= 0) {
                        if ($timeout_s &gt; 0) {
                            $timeout_us = 1000000 + $timeout_us;
                            $timeout_s--;
                        }
                    }

                    $start_s = $end_s;
                    $start_us = $end_us;
                }
            }
        } catch (SocketException $e) {
            if ($e-&gt;getCode() !== SocketException::CODE_NO_DATA) {
                // @codeCoverageIgnoreStart
                // It's impossible to reliably cause any other SocketException.
                // This line is only here in case the unthinkable happens:
                // The connection terminates just after it was supposedly
                // about to send back some data.
                throw $e;
                // @codeCoverageIgnoreEnd
            }
        }
        return $this-&gt;getPendingRequestsCount() !== 0;
    }

    /**
     * Gets the number of pending requests.
     * 
     * @return int The number of pending requests.
     * @see isRequestActive()
     */
    public function getPendingRequestsCount()
    {
        return $this-&gt;pendingRequestsCount;
    }

    /**
     * Cancels a request.
     * 
     * Cancels an active request. Using this function in favor of a plain call
     * to the &quot;/cancel&quot; command is highly reccomended, as it also updates the
     * counter of pending requests properly. Note that canceling a request also
     * removes any responses for it that were not previously extracted with
     * {@link extractNewResponses()}.
     * 
     * @param string $tag Tag of the request to cancel. Setting NULL will cancel
     *     all requests.
     * 
     * @return self|Client The client object.
     * @see sendAsync()
     * @see close()
     */
    public function cancelRequest($tag = null)
    {
        $cancelRequest = new Request('/cancel');
        $hasTag = !('' == $tag);
        $hasReg = null !== $this-&gt;registry;
        if ($hasReg &amp;&amp; !$hasTag) {
            $tags = array_merge(
                array_keys($this-&gt;responseBuffer),
                array_keys($this-&gt;callbacks)
            );
            $this-&gt;registry-&gt;setTaglessMode(true);
            foreach ($tags as $t) {
                $cancelRequest-&gt;setArgument(
                    'tag',
                    $this-&gt;registry-&gt;getOwnershipTag() . $t
                );
                $this-&gt;sendSync($cancelRequest);
            }
            $this-&gt;registry-&gt;setTaglessMode(false);
        } else {
            if ($hasTag) {
                if ($this-&gt;isRequestActive($tag)) {
                    if ($hasReg) {
                        $this-&gt;registry-&gt;setTaglessMode(true);
                        $cancelRequest-&gt;setArgument(
                            'tag',
                            $this-&gt;registry-&gt;getOwnershipTag() . $tag
                        );
                    } else {
                        $cancelRequest-&gt;setArgument('tag', $tag);
                    }
                } else {
                    throw new DataFlowException(
                        'No such request. Canceling aborted.',
                        DataFlowException::CODE_CANCEL_FAIL
                    );
                }
            }
            $this-&gt;sendSync($cancelRequest);
            if ($hasReg) {
                $this-&gt;registry-&gt;setTaglessMode(false);
            }
        }

        if ($hasTag) {
            if ($this-&gt;isRequestActive($tag, self::FILTER_BUFFER)) {
                $this-&gt;responseBuffer[$tag] = $this-&gt;completeRequest($tag);
            } else {
                $this-&gt;completeRequest($tag);
            }
        } else {
            $this-&gt;loop();
        }
        return $this;
    }

    /**
     * Sets response streaming setting.
     * 
     * Sets whether future responses are streamed. If responses are streamed,
     * the argument values are returned as streams instead of strings. This is
     * particularly useful if you expect a response that may contain one or more
     * very large words.
     * 
     * @param bool $streamingResponses Whether to stream future responses.
     * 
     * @return bool The previous value of the setting.
     * @see isStreamingResponses()
     */
    public function setStreamingResponses($streamingResponses)
    {
        $oldValue = $this-&gt;_streamingResponses;
        $this-&gt;_streamingResponses = (bool) $streamingResponses;
        return $oldValue;
    }

    /**
     * Gets response streaming setting.
     * 
     * Gets whether future responses are streamed.
     * 
     * @return bool The value of the setting.
     * @see setStreamingResponses()
     */
    public function isStreamingResponses()
    {
        return $this-&gt;_streamingResponses;
    }

    /**
     * Closes the opened connection, even if it is a persistent one.
     * 
     * Closes the opened connection, even if it is a persistent one. Note that
     * {@link extractNewResponses()} can still be used to extract responses
     * collected prior to the closing.
     * 
     * @return bool TRUE on success, FALSE on failure.
     */
    public function close()
    {
        $result = true;
        try {
            if ($this-&gt;com-&gt;getTransmitter()-&gt;getCrypto() === N::CRYPTO_OFF) {
                if (null !== $this-&gt;registry) {
                    $this-&gt;registry-&gt;setTaglessMode(true);
                }
                $response = $this-&gt;sendSync(new Request('/quit'));
                if (null !== $this-&gt;registry) {
                    $this-&gt;registry-&gt;setTaglessMode(false);
                }
                $result = $response-&gt;getType() === Response::TYPE_FATAL;
            }
            $result = $result &amp;&amp; $this-&gt;com-&gt;close();
        } catch (SocketException $e) {
            $result
                = $e-&gt;getCode() === SocketException::CODE_UNACCEPTING_REQEUST;
            if (null !== $this-&gt;registry) {
                $this-&gt;registry-&gt;setTaglessMode(false);
            }
        }
        $this-&gt;callbacks = array();
        $this-&gt;pendingRequestsCount = 0;
        return $result;
    }
    
    /**
     * Closes the connection, unless it's a persistent one.
     */
    public function __destruct()
    {
        if ($this-&gt;com-&gt;getTransmitter()-&gt;isPersistent()) {
            if (0 !== $this-&gt;pendingRequestsCount) {
                $this-&gt;cancelRequest();
            }
        } else {
            $this-&gt;close();
        }
    }

    /**
     * Sends a request to RouterOS.
     * 
     * @param Request $request The request to send.
     * 
     * @return self|Client The client object.
     * @see sendSync()
     * @see sendAsync()
     */
    protected function send(Request $request)
    {
        $request-&gt;send($this-&gt;com, $this-&gt;registry);
        $this-&gt;pendingRequestsCount++;
        return $this;
    }

    /**
     * Dispatches the next response in queue.
     * 
     * Dispatches the next response in queue, i.e. it executes the associated
     * callback if there is one, or places the response in the response buffer.
     * 
     * @param int $timeout_s  If a response is not immediatly available, wait
     *     this many seconds. If NULL, wait indefinetly.
     * @param int $timeout_us Microseconds to add to the waiting time.
     * 
     * @throws SocketException When there's no response within the time limit.
     * @return Response The dispatched response.
     */
    protected function dispatchNextResponse($timeout_s = 0, $timeout_us = 0)
    {
        $response = new Response(
            $this-&gt;com,
            $this-&gt;_streamingResponses,
            $timeout_s,
            $timeout_us,
            $this-&gt;registry
        );
        if ($response-&gt;getType() === Response::TYPE_FATAL) {
            $this-&gt;pendingRequestsCount = 0;
            $this-&gt;com-&gt;close();
            return $response;
        }

        $tag = $response-&gt;getTag();
        $isLastForRequest = $response-&gt;getType() === Response::TYPE_FINAL;
        if ($isLastForRequest) {
            $this-&gt;pendingRequestsCount--;
        }

        if ('' != $tag) {
            if ($this-&gt;isRequestActive($tag, self::FILTER_CALLBACK)) {
                if ($this-&gt;callbacks[$tag]($response, $this)) {
                    $this-&gt;cancelRequest($tag);
                } elseif ($isLastForRequest) {
                    unset($this-&gt;callbacks[$tag]);
                }
            } else {
                $this-&gt;responseBuffer[$tag][] = $response;
            }
        }
        return $response;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>